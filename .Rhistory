actions = tab$action
expect_true(unique(actions %in% c(1,2,3))) #the list of actions is in c(1,2,3)
state_prior = c(0.1,0.9)
tab = smsPOMDP::tab_actions(t, o, r, state_prior)
expect_equal(dim(tab)[2],2)#2 rows
expect_equal(sum(tab[,2]), Tmax+1)#Tmax + 1 years planning
actions = tab$action
expect_true(unique(actions %in% c(1,2,3))) #the list of actions is in c(1,2,3)
state_prior = c(0,1)
tab = smsPOMDP::tab_actions(t, o, r, state_prior)
expect_equal(dim(tab)[2],2)#2 rows
expect_equal(sum(tab[,2]), Tmax+1)#Tmax + 1 years planning
actions = tab$action
expect_true(unique(actions %in% c(1,2,3))) #the list of actions is in c(1,2,3)
?past_actions
?sim
#values for Sumatran tigers
pen = 0.1
p0 = 1-pen
pem = 0.05816
pm = 1 - pem
V = 175.133
Cm = 18.784
Cs = 10.840
d0 = 0.01
d = 0.78193
#Initial belief state
state_prior = c(0.9,0.1) #extant : 0.9, extinct : 0.1
#Horizon of the simulation
Tmax = 20
sim(p0, pm, d0, d, V, Cm, Cs, state_prior, Tmax)
library(testthat)
library(smsPOMDP)
test_dir("~/smsPOMDP/tests")
library(smsPOMDP)
?plot_stream
#values for Sumatran tigers
pen = 0.1
p0 = 1-pen
pem = 0.05816
pm = 1 - pem
V = 175.133
Cm = 18.784
Cs = 10.840
d0 = 0.01
d = 0.78193
s = c(1,0)
act = c('Manage', 'Manage', 'Survey','Stop')
obs = c('Not_seen','Not_seen','Not_seen','Seen')
plot_stream(p0, pm, d0, d, V, Cm, Cs, s, act, obs, disc = 0.95, size = 1)
plot_stream(p0, pm, d0, d, V, Cm, Cs, s, act, obs, disc = 0.95, size = 1)
library(vdiffr)
?expect_doppelganger()
library("ggplot2")
test_that("plots have known output", {
disp_hist_base <- function() hist(mtcars$disp)
expect_doppelganger("disp-histogram-base", disp_hist_base)
disp_hist_ggplot <- ggplot(mtcars, aes(disp)) + geom_histogram()
expect_doppelganger("disp-histogram-ggplot", disp_hist_ggplot)
})
library(devtools)
library("ggplot2")
test_that("plots have known output", {
disp_hist_base <- function() hist(mtcars$disp)
expect_doppelganger("disp-histogram-base", disp_hist_base)
disp_hist_ggplot <- ggplot(mtcars, aes(disp)) + geom_histogram()
expect_doppelganger("disp-histogram-ggplot", disp_hist_ggplot)
})
disp_hist_base <- function() hist(mtcars$disp)
expect_doppelganger("disp-histogram-base", disp_hist_base)
?manage_cases
manage_cases()
manage_cases("smsPOMDP")
setwd(~)
setwd('~')
manage_cases("smsPOMDP")
install('smsPOMDP')
install.packages("httpuv")
install('smsPOMDP')
library(devtools)
install('smsPOMDP')
library(testthat)
library(vdiffr)
manage_cases()
getwd()
manage_cases('smsPOMDP')
?expect_length
pen = 0.1 #local probability of extinction P(extinct/extant, survey or nothing)
p0 = 1-pen #local probability of persitance P(extant/extant, manage)
pem = 0.05816 #local probability of extinction if managed P(extinct/extant, manage)
pm = 1 - pem #local probability of persistance if managed P(extant/extant, manage)
d0 = 0.01 #local probability of detection P(present/extant, manage or nothing)
d = 0.78193 #local probability of detection if surveyed P(present/extant, survey)
V = 175.133 #Estimated economic value of the species ($/yr)
Cm = 18.784 #Estimated cost of managing ($/yr)
Cs = 10.840 #Estimated cost of surveying ($/yr)
#buiding the matrices of the problem
t = smsPOMDP::tr(p0, pm, d0, d, V, Cm, Cs) #transition matrix
o = smsPOMDP::obs(p0, pm, d0, d, V, Cm, Cs)#observation matrix
r = smsPOMDP::rew(p0, pm, d0, d, V, Cm, Cs) #reward matrix
state_prior = c(0.5,0.5) #initial belief state
log_dir = tempdir()
id <- digest::digest(match.call())
infile <- paste0(log_dir, "/", id, ".pomdpx")
outfile <- paste0(log_dir, "/", id, ".policyx")
stdout <- paste0(log_dir, "/", id, ".log")
sarsop::write_pomdpx(t, o, r, disc, state_prior, file = infile)
status <- sarsop::pomdpsol(infile, outfile, stdout = stdout)
policy <- sarsop::read_policyx(file = outfile)
output <- smsPOMDP::Interp_policy(state_prior,policy$vectors,policy$action)
disc = 0.95
#buiding the matrices of the problem
t = smsPOMDP::tr(p0, pm, d0, d, V, Cm, Cs) #transition matrix
o = smsPOMDP::obs(p0, pm, d0, d, V, Cm, Cs)#observation matrix
r = smsPOMDP::rew(p0, pm, d0, d, V, Cm, Cs) #reward matrix
state_prior = c(0.5,0.5) #initial belief state
log_dir = tempdir()
id <- digest::digest(match.call())
infile <- paste0(log_dir, "/", id, ".pomdpx")
outfile <- paste0(log_dir, "/", id, ".policyx")
stdout <- paste0(log_dir, "/", id, ".log")
sarsop::write_pomdpx(t, o, r, disc, state_prior, file = infile)
status <- sarsop::pomdpsol(infile, outfile, stdout = stdout)
policy <- sarsop::read_policyx(file = outfile)
output <- smsPOMDP::Interp_policy(state_prior,policy$vectors,policy$action)
output
dim(output)
size(output)
length()
length(output)
getwd()
install('smsPOMDP')
manage_cases('smsPOMDP')
vdiffr::last_collection_error()
library(smsPOMDP)
run_application()
library(vdiffr)
?vdiffr
collect_cases()
last_collection_error()
?last_collection_error
library(testthat)
library(smsPOMDP)
test_dir("~/smsPOMDP/tests")
test_check("smsPOMDP")
test_check()
library(vdiffr)
disp_hist_base <- function() hist(mtcars$disp)
vdiffr::expect_doppelganger("disp-histogram-base", disp_hist_base)
vdiffr::manage_cases("smsPOMDP")
getwd()
vdiffr::manage_cases()
pen = 0.1 #local probability of extinction P(extinct/extant, survey or nothing)
p0 = 1-pen #local probability of persitance P(extant/extant, manage)
pem = 0.05816 #local probability of extinction if managed P(extinct/extant, manage)
pm = 1 - pem #local probability of persistance if managed P(extant/extant, manage)
d0 = 0.01 #local probability of detection P(present/extant, manage or nothing)
d = 0.78193 #local probability of detection if surveyed P(present/extant, survey)
V = 175.133 #Estimated economic value of the species ($/yr)
Cm = 18.784 #Estimated cost of managing ($/yr)
Cs = 10.840 #Estimated cost of surveying ($/yr)
disc = 0.95
#buiding the matrices of the problem
t = smsPOMDP::tr(p0, pm, d0, d, V, Cm, Cs) #transition matrix
o = smsPOMDP::obs(p0, pm, d0, d, V, Cm, Cs)#observation matrix
r = smsPOMDP::rew(p0, pm, d0, d, V, Cm, Cs) #reward matrix
state_prior = c(0.5,0.5) #initial belief state
log_dir = tempdir()
id <- digest::digest(match.call())
infile <- paste0(log_dir, "/", id, ".pomdpx")
outfile <- paste0(log_dir, "/", id, ".policyx")
stdout <- paste0(log_dir, "/", id, ".log")
sarsop::write_pomdpx(t, o, r, disc, state_prior, file = infile)
status <- sarsop::pomdpsol(infile, outfile, stdout = stdout)
policy <- sarsop::read_policyx(file = outfile)
output <- smsPOMDP::Interp_policy(state_prior,policy$vectors,policy$action)
output
ppolicy
policy
vdiffr::manage_cases()
?plot_stream
disp =plot_stream(p0, pm, d0, d, V, Cm, Cs, s, act, obs, disc = 0.95, size = 1)
s = c(1,0)
act = c('Manage', 'Manage', 'Survey','Stop')
obs = c('Not_seen','Not_seen','Not_seen','Seen')
disp =plot_stream(p0, pm, d0, d, V, Cm, Cs, s, act, obs, disc = 0.95, size = 1)
manage_cases()
manage_cases()
test_dir("~/smsPOMDP/tests")
?minigraph
tab
10+2+89
trace(minigraph,edit = )
trace(minigraph,edit = t)
?smsPOMDP
?graph
library(smsPOMDP)
?compute_belief
install.packages("shinytest")
?validate
ui <- fluidPage(
checkboxGroupInput('in1', 'Check some letters', choices = head(LETTERS)),
selectizeInput('in2', 'Select a state', choices = state.name),
plotOutput('plot')
)
server <- function(input, output) {
output$plot <- renderPlot({
validate(
need(input$in1, 'Check at least one letter!'),
need(input$in2 != '', 'Please choose a state.')
)
plot(1:10, main = paste(c(input$in1, input$in2), collapse = ', '))
})
}
shinyApp(ui, server)
library(shiny)
ui <- fluidPage(
checkboxGroupInput('in1', 'Check some letters', choices = head(LETTERS)),
selectizeInput('in2', 'Select a state', choices = state.name),
plotOutput('plot')
)
server <- function(input, output) {
output$plot <- renderPlot({
validate(
need(input$in1, 'Check at least one letter!'),
need(input$in2 != '', 'Please choose a state.')
)
plot(1:10, main = paste(c(input$in1, input$in2), collapse = ', '))
})
}
shinyApp(ui, server)
?sim
ra= function(){
app <- shiny::shinyApp(
ui <- shiny::fluidPage(
shiny::titlePanel("POMDP solver: When to stop managing or surveying cryptic threatened species ?"),
shiny::sidebarLayout(
shiny::sidebarPanel("POMDP parameters"
, shiny::numericInput('p0', 'Local probability of persistence (if survey or stop)', min = 0, max = 1, value = 0.9)
, shiny::numericInput('pm', 'Local probability of persistence (if manage)', min = 0, max = 1, value = 0.94184)
, shiny::numericInput('d0', 'Local probability of detection (if manage or stop)', min = 0, max = 1, value = 0.01)
, shiny::numericInput('d', 'Local probability of detection (if survey)', min = 0, max = 1, value = 0.78193)
, shiny::numericInput('V', 'Estimated economic value of the species ($/yr)', value = 175.133)
, shiny::numericInput('Cm', 'Estimated cost of managing ($/yr)', value = 18.784)
, shiny::numericInput('Cs', 'Estimated cost of surveying ($/yr)', min = 0, max = 1, value = 10.840)
, shiny::numericInput('disc', 'Discount factor', value = 0.95, max = 1, min = 0)
, shiny::actionButton('sim', 'View simulation')
, shiny::actionButton('graph', 'View graphical solution')
, shiny::actionButton('past', 'Set history of management and observations')
, shiny::conditionalPanel('input.sim'
, shiny::helpText('Parameters only for the simulation')
, shiny::numericInput('Tmax', 'Duration of simulation', value = 10, min = 1)
, shiny::numericInput('b', 'Initial belief state (extant)', value = 1, min = 0, max = 1)
)
)
, shiny::mainPanel(""
, shiny::uiOutput('main')
)
)
),
server <- function(input, output, session){
#Inputs
p0 = shiny::reactive(input$p0)
pm = shiny::reactive(input$pm)
d0 = shiny::reactive(input$d0)
d = shiny::reactive(input$d)
V = shiny::reactive(input$V)
Cm = shiny::reactive(input$Cm)
Cs = shiny::reactive(input$Cs)
disc = shiny::reactive(input$disc)
b = shiny::reactive(input$b)
state_prior = shiny::reactive({c(b(), 1-b())})
Tmax = shiny::reactive(input$Tmax)
#different scenarios depending on the users choice
#launch a simulation
shiny::observeEvent(input$sim, {
output$plot = shiny::renderPlot({
validate(
need((input$p0 >= 0 && input$p0 <= 1), 'Local probability of persitance has to be between 0 and 1'),
need((input$pm >= 0 && input$pm <= 1), 'Local probability of persitance is has to be between 0 and 1'),
need((input$d0 >= 0 && input$d0 <= 1), 'Local probability of persitance is has to be between 0 and 1'),
need((input$d >= 0 && input$d <= 1), 'Local probability of persitance is has to be between 0 and 1'),
need((input$disc > 0 && input$disc <= 1), 'Local probability of persitance is has to be between 0 and 1'),
need((input$b >= 0 && input$b <= 1), 'Local probability of persitance is has to be between 0 and 1'),
need((input$Tmax >= 1), 'Local probability of persitance is has to be between 0 and 1'),
)
smsPOMDP::sim(p0(), pm(), d0(), d(), V(), Cm(), Cs(), state_prior(), Tmax(), disc(), size = 2)})
output$main = shiny::renderUI({
shiny::plotOutput('plot', height = '1000px')
})
})
#see decision graph
shiny::observeEvent(input$graph, {
output$plot = shiny::renderPlot({smsPOMDP::graph(p0(), pm(), d0(), d(), V(), Cm(), Cs(), c(1,0), disc(), size = 2)})
output$main = shiny::renderUI({
shiny::plotOutput('plot', height = '1000px')
})
})
#################################################################################
#give a set of past actions and observations and see the best following strategy#
#################################################################################
#correponding panel
shiny::observeEvent(input$past, {
output$main = shiny::renderUI({
shiny::tagList(
shiny::column(width = 2
, shiny::numericInput('length_past', "Number of years for past management", value = 1, min = 1)
, shiny::actionButton('submit_length_past', 'Submit')
, shiny::uiOutput('past_control')
)
, shiny::column(width = 9
, shiny::plotOutput('past_plot')
, shiny::conditionalPanel('input.submit_couple_1'
, shiny::actionButton('next_policy', 'Next policy')
, shiny::plotOutput('next_policy_plot')
)
)
)
})
})
#set past management stream
shiny::observeEvent(input$submit_length_past,{
output$past_control = shiny::renderUI({
shiny::tagList(
shiny::numericInput(inputId = 'past_init_b', 'Initial belief state (extant)', value = 1, min = 0, max = 1)
, shiny::h5(paste0('Year ', 1))
, shiny::selectInput(inputId = paste0("past_action_", 1)
,label = 'Action'
,choices = c('Manage', 'Survey', 'Stop')
, selected = 'Manage')
, shiny::selectInput(inputId = paste0("past_obs_", 1)
,label = 'Observation'
,choices = c('Seen', 'Not_seen')
, selected = 'Seen')
, shiny::actionButton(inputId = paste0("submit_couple_", 1)
, label = 'Submit')
, shiny::conditionalPanel('input.length_past > 1',
lapply(c(2:input$length_past),
function(i){
shiny::conditionalPanel(paste0('input.submit_couple_', i-1)
, shiny::h5(paste0('Year ', i))
, shiny::selectInput(inputId = paste0("past_action_", i)
,label = 'Action'
,choices = c('Manage', 'Survey', 'Stop')
, selected = 'Manage')
, shiny::selectInput(inputId = paste0("past_obs_", i)
,label = 'Observation'
,choices = c('Seen', 'Not_seen')
, selected = 'Seen')
, shiny::actionButton(inputId = paste0("submit_couple_", i)
, label = 'Submit')
)
})
)
)
})
})
p_a = shiny::reactive(smsPOMDP::past_actions(input)) #past actions
p_o = shiny::reactive(smsPOMDP::past_obs(input)) #past observations
init_belief = shiny::reactive({c(input$past_init_b, 1-input$past_init_b)}) #initial belief state
current_belief = shiny::reactive(smsPOMDP::compute_belief(p0(), pm(), d0(), d(), V(), Cm(), Cs(),init_belief(), p_a(), p_o(), disc()))
#
shiny::observeEvent(input$submit_couple_1, {
output$past_plot = shiny::renderPlot(smsPOMDP::plot_stream(p0(), pm(), d0(), d(), V(), Cm(), Cs(),init_belief(), p_a(), p_o(), disc(), size = 2))
})
shiny::observeEvent(input$next_policy, {
output$next_policy_plot = shiny::renderPlot({smsPOMDP::graph(p0(), pm(), d0(), d(), V(), Cm(), Cs(), current_belief(), disc())})
})
}
)
shiny::runApp(app)
}
ra()
?validate
ra()
p0
smsPOMDP::sim(p0, pm, d0, d, V, Cm, Cs, state_prior, Tmax, disc, size = 2)})
smsPOMDP::sim(p0, pm, d0, d, V, Cm, Cs, state_prior, Tmax, disc, size = 2)
disc = 0.95
smsPOMDP::sim(p0, pm, d0, d, V, Cm, Cs, state_prior, Tmax, disc, size = 2)
#' @export
run_application = function(){
app <- shiny::shinyApp(
ui <- shiny::fluidPage(
shiny::titlePanel("POMDP solver: When to stop managing or surveying cryptic threatened species ?"),
shiny::sidebarLayout(
shiny::sidebarPanel("POMDP parameters"
, shiny::numericInput('p0', 'Local probability of persistence (if survey or stop)', min = 0, max = 1, value = 0.9)
, shiny::numericInput('pm', 'Local probability of persistence (if manage)', min = 0, max = 1, value = 0.94184)
, shiny::numericInput('d0', 'Local probability of detection (if manage or stop)', min = 0, max = 1, value = 0.01)
, shiny::numericInput('d', 'Local probability of detection (if survey)', min = 0, max = 1, value = 0.78193)
, shiny::numericInput('V', 'Estimated economic value of the species ($/yr)', value = 175.133)
, shiny::numericInput('Cm', 'Estimated cost of managing ($/yr)', value = 18.784)
, shiny::numericInput('Cs', 'Estimated cost of surveying ($/yr)', min = 0, max = 1, value = 10.840)
, shiny::numericInput('disc', 'Discount factor', value = 0.95, max = 1, min = 0)
, shiny::actionButton('sim', 'View simulation')
, shiny::actionButton('graph', 'View graphical solution')
, shiny::actionButton('past', 'Set history of management and observations')
, shiny::conditionalPanel('input.sim'
, shiny::helpText('Parameters only for the simulation')
, shiny::numericInput('Tmax', 'Duration of simulation', value = 10, min = 1)
, shiny::numericInput('b', 'Initial belief state (extant)', value = 1, min = 0, max = 1)
)
)
, shiny::mainPanel(""
, shiny::uiOutput('main')
)
)
),
server <- function(input, output, session){
#Inputs
p0 = shiny::reactive(input$p0)
pm = shiny::reactive(input$pm)
d0 = shiny::reactive(input$d0)
d = shiny::reactive(input$d)
V = shiny::reactive(input$V)
Cm = shiny::reactive(input$Cm)
Cs = shiny::reactive(input$Cs)
disc = shiny::reactive(input$disc)
b = shiny::reactive(input$b)
state_prior = shiny::reactive({c(b(), 1-b())})
Tmax = shiny::reactive(input$Tmax)
#different scenarios depending on the users choice
#launch a simulation
shiny::observeEvent(input$sim, {
output$plot = shiny::renderPlot({smsPOMDP::sim(p0(), pm(), d0(), d(), V(), Cm(), Cs(), state_prior(), Tmax(), disc(), size = 2)})
output$main = shiny::renderUI({
shiny::plotOutput('plot', height = '1000px')
})
})
#see decision graph
shiny::observeEvent(input$graph, {
output$plot = shiny::renderPlot({smsPOMDP::graph(p0(), pm(), d0(), d(), V(), Cm(), Cs(), c(1,0), disc(), size = 2)})
output$main = shiny::renderUI({
shiny::plotOutput('plot', height = '1000px')
})
})
#################################################################################
#give a set of past actions and observations and see the best following strategy#
#################################################################################
#correponding panel
shiny::observeEvent(input$past, {
output$main = shiny::renderUI({
shiny::tagList(
shiny::column(width = 2
, shiny::numericInput('length_past', "Number of years for past management", value = 1, min = 1)
, shiny::actionButton('submit_length_past', 'Submit')
, shiny::uiOutput('past_control')
)
, shiny::column(width = 9
, shiny::plotOutput('past_plot')
, shiny::conditionalPanel('input.submit_couple_1'
, shiny::actionButton('next_policy', 'Next policy')
, shiny::plotOutput('next_policy_plot')
)
)
)
})
})
#set past management stream
shiny::observeEvent(input$submit_length_past,{
output$past_control = shiny::renderUI({
shiny::tagList(
shiny::numericInput(inputId = 'past_init_b', 'Initial belief state (extant)', value = 1, min = 0, max = 1)
, shiny::h5(paste0('Year ', 1))
, shiny::selectInput(inputId = paste0("past_action_", 1)
,label = 'Action'
,choices = c('Manage', 'Survey', 'Stop')
, selected = 'Manage')
, shiny::selectInput(inputId = paste0("past_obs_", 1)
,label = 'Observation'
,choices = c('Seen', 'Not_seen')
, selected = 'Seen')
, shiny::actionButton(inputId = paste0("submit_couple_", 1)
, label = 'Submit')
, shiny::conditionalPanel('input.length_past > 1',
lapply(c(2:input$length_past),
function(i){
shiny::conditionalPanel(paste0('input.submit_couple_', i-1)
, shiny::h5(paste0('Year ', i))
, shiny::selectInput(inputId = paste0("past_action_", i)
,label = 'Action'
,choices = c('Manage', 'Survey', 'Stop')
, selected = 'Manage')
, shiny::selectInput(inputId = paste0("past_obs_", i)
,label = 'Observation'
,choices = c('Seen', 'Not_seen')
, selected = 'Seen')
, shiny::actionButton(inputId = paste0("submit_couple_", i)
, label = 'Submit')
)
})
)
)
})
})
p_a = shiny::reactive(smsPOMDP::past_actions(input)) #past actions
p_o = shiny::reactive(smsPOMDP::past_obs(input)) #past observations
init_belief = shiny::reactive({c(input$past_init_b, 1-input$past_init_b)}) #initial belief state
current_belief = shiny::reactive(smsPOMDP::compute_belief(p0(), pm(), d0(), d(), V(), Cm(), Cs(),init_belief(), p_a(), p_o(), disc()))
#
shiny::observeEvent(input$submit_couple_1, {
output$past_plot = shiny::renderPlot(smsPOMDP::plot_stream(p0(), pm(), d0(), d(), V(), Cm(), Cs(),init_belief(), p_a(), p_o(), disc(), size = 2))
})
shiny::observeEvent(input$next_policy, {
output$next_policy_plot = shiny::renderPlot({smsPOMDP::graph(p0(), pm(), d0(), d(), V(), Cm(), Cs(), current_belief(), disc())})
})
}
)
shiny::runApp(app)
}
run_application()
