, shiny::h5(paste0('Year ', i))
, shiny::selectInput(inputId = paste0("past_action_", i)
,label = 'Action'
,choices = c('Manage', 'Survey', 'Stop')
, selected = 'Manage')
, shiny::selectInput(inputId = paste0("past_obs_", i)
,label = 'Observation'
,choices = c('Seen', 'Not_seen')
, selected = 'Seen')
, shiny::actionButton(inputId = paste0("submit_couple_", i)
, label = 'Submit')
)
})
)
)
})
})
p_a = shiny::reactive(smsPOMDP::past_actions(input)) #past actions
p_o = shiny::reactive(smsPOMDP::past_obs(input)) #past observations
init_belief = shiny::reactive({c(input$past_init_b, 1-input$past_init_b)}) #initial belief state
current_belief = shiny::reactive(smsPOMDP::compute_belief(p0(), pm(), d0(), d(), V(), Cm(), Cs(),init_belief(), p_a(), p_o(), disc()))
#
shiny::observeEvent(input$submit_couple_1, {
output$past_plot = shiny::renderPlot(smsPOMDP::plot_stream(p0(), pm(), d0(), d(), V(), Cm(), Cs(),init_belief(), p_a(), p_o(), disc(), size = 2))
})
shiny::observeEvent(input$next_policy, {
output$next_policy_plot = shiny::renderPlot({smsPOMDP::graph(p0(), pm(), d0(), d(), V(), Cm(), Cs(), current_belief(), disc())})
})
}
)
shiny::runApp(app)
}
ra()
?validate
ra()
p0
smsPOMDP::sim(p0, pm, d0, d, V, Cm, Cs, state_prior, Tmax, disc, size = 2)})
smsPOMDP::sim(p0, pm, d0, d, V, Cm, Cs, state_prior, Tmax, disc, size = 2)
disc = 0.95
smsPOMDP::sim(p0, pm, d0, d, V, Cm, Cs, state_prior, Tmax, disc, size = 2)
#' @export
run_application = function(){
app <- shiny::shinyApp(
ui <- shiny::fluidPage(
shiny::titlePanel("POMDP solver: When to stop managing or surveying cryptic threatened species ?"),
shiny::sidebarLayout(
shiny::sidebarPanel("POMDP parameters"
, shiny::numericInput('p0', 'Local probability of persistence (if survey or stop)', min = 0, max = 1, value = 0.9)
, shiny::numericInput('pm', 'Local probability of persistence (if manage)', min = 0, max = 1, value = 0.94184)
, shiny::numericInput('d0', 'Local probability of detection (if manage or stop)', min = 0, max = 1, value = 0.01)
, shiny::numericInput('d', 'Local probability of detection (if survey)', min = 0, max = 1, value = 0.78193)
, shiny::numericInput('V', 'Estimated economic value of the species ($/yr)', value = 175.133)
, shiny::numericInput('Cm', 'Estimated cost of managing ($/yr)', value = 18.784)
, shiny::numericInput('Cs', 'Estimated cost of surveying ($/yr)', min = 0, max = 1, value = 10.840)
, shiny::numericInput('disc', 'Discount factor', value = 0.95, max = 1, min = 0)
, shiny::actionButton('sim', 'View simulation')
, shiny::actionButton('graph', 'View graphical solution')
, shiny::actionButton('past', 'Set history of management and observations')
, shiny::conditionalPanel('input.sim'
, shiny::helpText('Parameters only for the simulation')
, shiny::numericInput('Tmax', 'Duration of simulation', value = 10, min = 1)
, shiny::numericInput('b', 'Initial belief state (extant)', value = 1, min = 0, max = 1)
)
)
, shiny::mainPanel(""
, shiny::uiOutput('main')
)
)
),
server <- function(input, output, session){
#Inputs
p0 = shiny::reactive(input$p0)
pm = shiny::reactive(input$pm)
d0 = shiny::reactive(input$d0)
d = shiny::reactive(input$d)
V = shiny::reactive(input$V)
Cm = shiny::reactive(input$Cm)
Cs = shiny::reactive(input$Cs)
disc = shiny::reactive(input$disc)
b = shiny::reactive(input$b)
state_prior = shiny::reactive({c(b(), 1-b())})
Tmax = shiny::reactive(input$Tmax)
#different scenarios depending on the users choice
#launch a simulation
shiny::observeEvent(input$sim, {
output$plot = shiny::renderPlot({smsPOMDP::sim(p0(), pm(), d0(), d(), V(), Cm(), Cs(), state_prior(), Tmax(), disc(), size = 2)})
output$main = shiny::renderUI({
shiny::plotOutput('plot', height = '1000px')
})
})
#see decision graph
shiny::observeEvent(input$graph, {
output$plot = shiny::renderPlot({smsPOMDP::graph(p0(), pm(), d0(), d(), V(), Cm(), Cs(), c(1,0), disc(), size = 2)})
output$main = shiny::renderUI({
shiny::plotOutput('plot', height = '1000px')
})
})
#################################################################################
#give a set of past actions and observations and see the best following strategy#
#################################################################################
#correponding panel
shiny::observeEvent(input$past, {
output$main = shiny::renderUI({
shiny::tagList(
shiny::column(width = 2
, shiny::numericInput('length_past', "Number of years for past management", value = 1, min = 1)
, shiny::actionButton('submit_length_past', 'Submit')
, shiny::uiOutput('past_control')
)
, shiny::column(width = 9
, shiny::plotOutput('past_plot')
, shiny::conditionalPanel('input.submit_couple_1'
, shiny::actionButton('next_policy', 'Next policy')
, shiny::plotOutput('next_policy_plot')
)
)
)
})
})
#set past management stream
shiny::observeEvent(input$submit_length_past,{
output$past_control = shiny::renderUI({
shiny::tagList(
shiny::numericInput(inputId = 'past_init_b', 'Initial belief state (extant)', value = 1, min = 0, max = 1)
, shiny::h5(paste0('Year ', 1))
, shiny::selectInput(inputId = paste0("past_action_", 1)
,label = 'Action'
,choices = c('Manage', 'Survey', 'Stop')
, selected = 'Manage')
, shiny::selectInput(inputId = paste0("past_obs_", 1)
,label = 'Observation'
,choices = c('Seen', 'Not_seen')
, selected = 'Seen')
, shiny::actionButton(inputId = paste0("submit_couple_", 1)
, label = 'Submit')
, shiny::conditionalPanel('input.length_past > 1',
lapply(c(2:input$length_past),
function(i){
shiny::conditionalPanel(paste0('input.submit_couple_', i-1)
, shiny::h5(paste0('Year ', i))
, shiny::selectInput(inputId = paste0("past_action_", i)
,label = 'Action'
,choices = c('Manage', 'Survey', 'Stop')
, selected = 'Manage')
, shiny::selectInput(inputId = paste0("past_obs_", i)
,label = 'Observation'
,choices = c('Seen', 'Not_seen')
, selected = 'Seen')
, shiny::actionButton(inputId = paste0("submit_couple_", i)
, label = 'Submit')
)
})
)
)
})
})
p_a = shiny::reactive(smsPOMDP::past_actions(input)) #past actions
p_o = shiny::reactive(smsPOMDP::past_obs(input)) #past observations
init_belief = shiny::reactive({c(input$past_init_b, 1-input$past_init_b)}) #initial belief state
current_belief = shiny::reactive(smsPOMDP::compute_belief(p0(), pm(), d0(), d(), V(), Cm(), Cs(),init_belief(), p_a(), p_o(), disc()))
#
shiny::observeEvent(input$submit_couple_1, {
output$past_plot = shiny::renderPlot(smsPOMDP::plot_stream(p0(), pm(), d0(), d(), V(), Cm(), Cs(),init_belief(), p_a(), p_o(), disc(), size = 2))
})
shiny::observeEvent(input$next_policy, {
output$next_policy_plot = shiny::renderPlot({smsPOMDP::graph(p0(), pm(), d0(), d(), V(), Cm(), Cs(), current_belief(), disc())})
})
}
)
shiny::runApp(app)
}
run_application()
library(devtools)
build()
install()
trace(minigraph,edit =T)
library(smsPOMDP)
trace(minigraph,edit =T)
library(testthat)
library(smsPOMDP)
test_dir("~/smsPOMDP/tests")
library(vdiffr)
manage_cases()
build()
install()
manage_cases()
test_dir("~/smsPOMDP/tests")
devtools::test()
vdiffr::manage_cases()
build()
install()
vdiffr::manage_cases()
devtools::test()
test_check('smsPOMDP')
test_dir("~/smsPOMDP/tests")
test_dir("~/smsPOMDP/tests")
?graph
pen = 0.1
p0 = 1-pen
pem = 0.05816
pm = 1 - pem
V = 175.133
Cm = 18.784
Cs = 10.840
d0 = 0.01
d = 0.78193
#Initial belief state
state_prior = c(0.9,0.1) #extant : 0.9, extinct : 0.1
graph(p0, pm, d0, d, V, Cm, Cs, state_prior)
build()
install()
manage_cases()
manage_cases()
build()
install()
install()
library(testthat)
?comtext
?context
build()
install()
build()
library(devtools)
build()
install()
library(devtools)
library(vdiffr)
library(testthat)
library(smsPOMDP)
build()
install()
manage_cases()
manage_cases()
vdiffr::manage_cases()
devtools::test()
build()
install()
library(smsPOMDP)
manage_cases()
test_dir("~/smsPOMDP/tests")
test_check()
test_check("smsPOMDP")
vdiffr::manage_cases()
vdiffr::last_collection_error()
vdiffr::manage_cases()
build()
install()
test_dir("~/smsPOMDP/tests")
#' @export
tab_actions = function(transition, observation, reward, state_prior, disc = 0.95, Tmax = 100){
stopifnot(check_square_stochastic(transition[,,1]))
stopifnot(check_square_stochastic(transition[,,2]))
stopifnot(check_square_stochastic(transition[,,3]))
stopifnot(check_stochastic(observation[,,1]))
stopifnot(check_stochastic(observation[,,2]))
stopifnot(check_stochastic(observation[,,3]))
log_dir = tempdir()
id <- digest::digest(match.call())
infile <- paste0(log_dir, "/", id, ".pomdpx")
outfile <- paste0(log_dir, "/", id, ".policyx")
stdout <- paste0(log_dir, "/", id, ".log")
sarsop::write_pomdpx(transition, observation, reward, disc, state_prior, file = infile)
status <- sarsop::pomdpsol(infile, outfile, stdout = stdout)
policy <- sarsop::read_policyx(file = outfile)
output <- smsPOMDP::Interp_policy(state_prior,policy$vectors,policy$action)
state_posterior = matrix(state_prior, ncol = 2)
optimal_action = output[[2]]
for (i in c(1:(Tmax))) {
a1 = optimal_action[i]
o1 = 2 #we treat the case when the species is not seen
s_p <- smsPOMDP::update_belief(state_posterior[i, ], transition, observation, o1,
a1)
state_posterior = rbind(state_posterior, s_p)
output <- Interp_policy(s_p,policy$vectors,policy$action)
optimal_action = c(optimal_action, output[[2]])
}
a = optimal_action[1]
act = a
years = numeric()
while(sum(years) < length(optimal_action)){
if (length(unique(optimal_action))==1){
i = length(optimal_action)
years = c(years, i)
break
} else {
i = min(which(optimal_action!= a))-1
optimal_action = optimal_action[-c(1:i)]
a = optimal_action[1]
act = c(act,a)
years = c(years, i)
}
}
tab = data.frame(action = act, years = years)
return(tab)
}
test_dir("~/smsPOMDP/tests")
class(output)
pen = 0.1 #local probability of extinction P(extinct/extant, survey or nothing)
p0 = 1-pen #local probability of persitance P(extant/extant, manage)
pem = 0.05816 #local probability of extinction if managed P(extinct/extant, manage)
pm = 1 - pem #local probability of persistance if managed P(extant/extant, manage)
d0 = 0.01 #local probability of detection P(present/extant, manage or nothing)
d = 0.78193 #local probability of detection if surveyed P(present/extant, survey)
V = 175.133 #Estimated economic value of the species ($/yr)
Cm = 18.784 #Estimated cost of managing ($/yr)
Cs = 10.840 #Estimated cost of surveying ($/yr)
disc = 0.95
#buiding the matrices of the problem
t = smsPOMDP::tr(p0, pm, d0, d, V, Cm, Cs) #transition matrix
o = smsPOMDP::obs(p0, pm, d0, d, V, Cm, Cs)#observation matrix
r = smsPOMDP::rew(p0, pm, d0, d, V, Cm, Cs) #reward matrix
state_prior = c(0.5,0.5) #initial belief state
log_dir = tempdir()
id <- digest::digest(match.call())
infile <- paste0(log_dir, "/", id, ".pomdpx")
outfile <- paste0(log_dir, "/", id, ".policyx")
stdout <- paste0(log_dir, "/", id, ".log")
sarsop::write_pomdpx(t, o, r, disc, state_prior, file = infile)
status <- sarsop::pomdpsol(infile, outfile, stdout = stdout)
policy <- sarsop::read_policyx(file = outfile)
output <- smsPOMDP::Interp_policy(state_prior,policy$vectors,policy$action)
expect_equal(length(output), 2)#value and actions
output
output = c(output)
expect_equal(length(output), 2)#value and actions
test_dir("~/smsPOMDP/tests")
manage_cases()
build()
install()
install.packages("scales")
install()
library(devtools)
install()
test_dir("~/smsPOMDP/tests")
library(testthat)
library(smsPOMDP)
test_dir("~/smsPOMDP/tests")
library(vdiffr)
manage_cases()
manage_cases()
test_dir("~/smsPOMDP/tests")
test_dir("~/smsPOMDP/tests")
library(devtools)
test()
test()
test()
builld()
build()
install()
tab_actions()
tab_actions
library(smsPOMDP)
test()
test()
test()
test_check("smsPOMDP")
?test_check
test_package('smsPOMDP')
build()
install()
library(smsPOMDP)
test_package('smsPOMDP')
build()
test_package('smsPOMDP')
remove.packages("smsPOMDP", lib="~/R/win-library/3.6")
build()
install()
test_package('smsPOMDP')
test_dir(paste(path.package("smsPOMDP"),"/tests/",sep=""))
fpath <- system.file("extdata", "im1.jpg", package="smsPOMDP")
fpath
build()
install()
test_dir("~/smsPOMDP/tests")
test_dir("~/smsPOMDP/tests")
?minigraph
## Not run:
##values for Sumatran tigers
pen = 0.1
p0 = 1-pen
pem = 0.05816
pm = 1 - pem
V = 175.133
Cm = 18.784
Cs = 10.840
d0 = 0.01
d = 0.78193
disc = 0.95
state_prior = c(1,0)
t = smsPOMDP::tr(p0, pm, d0, d, V, Cm, Cs)
o = smsPOMDP::obs(p0, pm, d0, d, V, Cm, Cs)
r = smsPOMDP::rew(p0, pm, d0, d, V, Cm, Cs)
tab = smsPOMDP::tab_actions(t, o, r, state_prior, disc)
smsPOMDP::minigraph(tab)
## Not run:
##values for Sumatran tigers
pen = 0.1
p0 = 1-pen
pem = 0.05816
pm = 1 - pem
V = 175.133
Cm = 18.784
Cs = 10.840
d0 = 0.01
d = 0.78193
disc = 0.95
state_prior = c(1,0)
t = smsPOMDP::tr(p0, pm, d0, d, V, Cm, Cs)
o = smsPOMDP::obs(p0, pm, d0, d, V, Cm, Cs)
r = smsPOMDP::rew(p0, pm, d0, d, V, Cm, Cs)
tab = smsPOMDP::tab_actions(t, o, r, state_prior, disc)
smsPOMDP::minigraph(tab, size = 0.7)
library(vdiffr)
collect_cases()
collect_cases()
build()
test_file('~/smsPOMDP/tests/testthat/test-plot_stream.R')
test_file('~/sms tests/test-Interp_policy.R')
test_file('~/sms tests/test-minigraph.R')
test_file('~/smsPOMDP/tests/testthat/test-minigraph.R')
test_file('~/smsPOMDP/tests/testthat/test-graph.R')
test_file('~/smsPOMDP/tests/testthat/test_graph.R')
test_file('~/smsPOMDP/tests/testthat/test-plot_stream.R)
')'
')
test_file('~/smsPOMDP/tests/testthat/test-plot_stream.R')
test_file('~/smsPOMDP/tests/testthat/test-Interp_policy.R')
id
test_file('~/smsPOMDP/tests/testthat/test-Interp_policy.R')
manage_cases()
test_file('~/smsPOMDP/tests/testthat/test-minigraph.R')
test_file('~/smsPOMDP/tests/testthat/test-graph.R')
test_dir("~/smsPOMDP/tests")
memory.limit()
memory.limit
ls()
build()
install()
build()
install()
#install.packages("devtools")
#devtools::install_github("klutometis/roxygen")
library("devtools")
library(roxygen2)
document()
build()
install()
test_dir("~/smsPOMDP/tests")
options()
options(expression = default_value)
remotes::install_github('conservation-decisions/smsPOMDP')
test_file('tests/testthat/test-main_graph.R')
test_check("smsPOMDP")
test_dir("~/smsPOMDP/tests")
traceback()
options(expressions=500)
test_dir("~/smsPOMDP/tests")
powerc.fun <- function(n,sigma,r){
a <- 0.05
d <- seq(-20,20,2)
power <- rep(NA,length(d))
p.lab <- rep(NA,length(d))
for (j in 1:length(d)){
mu1 <- 110
mu2 <- mu1-d[j]
reject <- rep(NA,r)
for (i in 1:r){
sample1 <- rnorm(n,mu1,sigma)
sample2 <- rnorm(n,mu2,sigma)
sample.t <- t.test(sample1,sample2)
p.val <- sample.t[3]
reject[i] <- p.val<a
power[j] <- sum(reject)/length(reject)
p.lab[j] <- paste('d=',d[j],sep='')
}}
d.power <- cbind(d,power)
p.plot <- plot(d.power[,1], d.power[,2], type="l", xlab=bquote(H[a]), ylab="Power", main="Power Calculations for Two Sample T Test")
return(list(p.plot, d.power))
}
# prints the plot and saves d.power values
output <- powerc.fun(100,0.1,10)
# d.power values
output[[2]]
output[[1]]
output
test_dir("~/smsPOMDP/tests")
CStack_info()
test_dir("~/smsPOMDP/tests")
test_dir("~/smsPOMDP/tests")
remove.packages("smsPOMDP", lib="~/R/win-library/3.6")
test_dir("~/smsPOMDP/tests")
test_dir("~/smsPOMDP/tests")
library(testthat)
test_dir("~/smsPOMDP/tests")
traceback()
test_check("smsPOMDP")
build()
library(devtools)
build()
install()
library(smsPOMMD)
library(smsPOMDP)
library(testthat)
library(smsPOMDP)
test_dir("~/smsPOMDP/tests")
loadNamespace()
loadNamespace(vdiffr)
loadNamespace('vdiffr')
library(vdiffr)
loadNamespace('vdiffr')
test_dir("~/smsPOMDP/tests")
test_file('tests/testthat/test-plot_stream.R')
