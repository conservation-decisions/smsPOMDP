print("Incompatibility between transition and reward dimensions")
test_passed <- FALSE
}
}
#checking observation matrix
if (test_passed) {
s4 <- dim(observation)[1]#number of states of the observation matrix
o1 <- dim(observation)[2]#number of observations of the observation matrix
a3 <- dim(observation)[3]#number of actions of the observation matrix
if (s4 < 1 | a3 < 1) {
print("The observation matrix R must be an array (S,O,A) with
S: number of states greater than 0
O: number of states greater than 0
and A : number of actions greater than 0")
test_passed <- FALSE
}
}
if (test_passed) {
a <- 1
while (a <= a1) {
pass <- smsPOMDP::check_stochastic(observation[,,a])
#pass=TRUE if transition[,,a] is square stochastic
if (pass) {
a <- a + 1
} else {
a <- a1 + 1
print('The observation array must be stochastic')
test_passed <- FALSE
}
}
}
if (test_passed) {
if (s1 != s4 | a1 != a3) {
print("Incompatibility between transition and observation dimensions")
test_passed <- FALSE
}
}
return(test_passed)
}
#values for Sumatran tigers
pen <- 0.1
p0 <- 1-pen
pem <- 0.05816
pm <- 1 - pem
V <- 175.133
Cm <- 18.784
Cs <- 10.840
d0 <- 0.01
d <- 0.78193
t <- smsPOMDP::tr(p0, pm, d0, d, V, Cm, Cs) #transition matrix
o <- smsPOMDP::obs(p0, pm, d0, d, V, Cm, Cs)#observation matrix
r <- smsPOMDP::rew(p0, pm, d0, d, V, Cm, Cs)#reward matrix
check_pomdp1(t, o, r)
testthat::expect_true(smsPOMDP::check_pomdp(t1, o, r))
#EXPECT TO FAIL THE TEST
t1 <- array(0, dim = c(2,2,3))
testthat::expect_false(smsPOMDP::check_pomdp(t1, o, r))
t1
testthat::expect_false(smsPOMDP::check_pomdp(t1, o, r))
testthat::expect_false(check_pomdp1(t1, o, r))
testthat::expect_false(smsPOMDP::check_pomdp(t, o1, r))
#not stochastic observation
o1 <- array(0, dim = c(2,2,3))
testthat::expect_false(smsPOMDP::check_pomdp(t, o1, r))
testthat::expect_false(smsPOMDP::check_pomdp(t, o, r1))
#not compatible number of actions: transition and reward
r1 <- array(0, dim = c(2,2))
testthat::expect_false(smsPOMDP::check_pomdp(t, o, r1))
#not compatible number of actions: transition and observation
o2 <- array(c(o[,,1], o[,,2]), dim = c(2,2,2))
testthat::expect_false(smsPOMDP::check_pomdp(t, o2, r))
o
remove.packages("smsPOMDP", lib="~/R/win-library/3.6")
library(devtools)
document()
goodpractice::gp()
?need
build()
install()
test_file("~/smsPOMDP/tests/testthat/test-compute_belief.R")
test_file("~/smsPOMDP/tests/testthat/test-Interp_policy.R")
test_file("~/smsPOMDP/tests/testthat/test-graph.R")
test_file("~/smsPOMDP/tests/testthat/test-minigraph.R")
test_file("~/smsPOMDP/tests/testthat/test-obs.R")
test_file("~/smsPOMDP/tests/testthat/test-plot_stream.R")
test_file("~/smsPOMDP/tests/testthat/test-rew.R")
test_file("~/smsPOMDP/tests/testthat/test-tab_actions.R")
test_file("~/smsPOMDP/tests/testthat/test-tr.R")
test_file("~/smsPOMDP/tests/testthat/test-update_belief.R")
test_file('~/smsPOMDP/tests/testthat/test-run_application.R')
# Code used to check run_application
# the folder smsPOMDP/tests/testthat/app/ contains a file calling run_application
library(shinytest)
library(shiny)
# Code used to check run_application
# the folder smsPOMDP/tests/testthat/app/ contains a file calling run_application
library(shinytest)
library(shiny)
recordTest("~/smsPOMDP/tests/testthat/app/")
remove.packages("smsPOMDP", lib="~/R/win-library/3.6")
build()
library(devtools)
document()
build()
install()
# Code used to check run_application
# the folder smsPOMDP/tests/testthat/app/ contains a file calling run_application
library(shinytest)
library(shiny)
recordTest("~/smsPOMDP/tests/testthat/app/")
goodpractice::gp()
goodpractice::gp()
build()
install()
library(testthat)
library(smsPOMDP)
test_package('smsPOMDP')
? usethis::use_testthat()
usethis::use_testthat()
remove.packages("smsPOMDP", lib="~/R/win-library/3.6")
library(testthat)
library(shinytest)
library(shiny)
recordTest('~/smsPOMDP/tests/testthat/app/')
library(devtools)
build()
intstall()
install()
recordTest('~/smsPOMDP/tests/testthat/app/')
?testApp
recordTest('~/smsPOMDP/tests/testthat/app/')
test_file('tests/testthat/test-run_application.R')
testApp("app", compareImages = FALSE)
system.file('app', package = 'smsPOMDP')
# Use compareImages=FALSE because the expected image screenshots were created
# on a Mac, and they will differ from screenshots taken on the CI platform,
# which runs on Linux.
app_path <- system.file('testthat/app', package = 'smsPOMDP')
app_path
# Use compareImages=FALSE because the expected image screenshots were created
# on a Mac, and they will differ from screenshots taken on the CI platform,
# which runs on Linux.
app_path <- system.file('test/testthat/app', package = 'smsPOMDP')
app_path
build()
install()
# Use compareImages=FALSE because the expected image screenshots were created
# on a Mac, and they will differ from screenshots taken on the CI platform,
# which runs on Linux.
app_path <- system.file('test/testthat/app', package = 'smsPOMDP')
app_path
# Use compareImages=FALSE because the expected image screenshots were created
# on a Mac, and they will differ from screenshots taken on the CI platform,
# which runs on Linux.
app_path <- system.file('test/testthat/app/', package = 'smsPOMDP')
# Use compareImages=FALSE because the expected image screenshots were created
# on a Mac, and they will differ from screenshots taken on the CI platform,
# which runs on Linux.
app_path <- system.file('test/testthat/app/app.R', package = 'smsPOMDP')
testApp(run_application())
library(devtools)
build()
install()
testApp(appdir, compareImages = FALSE)
library(shinytest)
testApp(appdir, compareImages = FALSE)
appdir <- system.file(package = "smsPOMDP", "app")
testApp(appdir, compareImages = FALSE)
expect_pass(testApp(appdir, compareImages = FALSE))
test_check('smsPOMDP')
testthat::test_check('smsPOMDP')
library(shinytest)
recordTest('inst/app/')
build()
install()
remove.packages("smsPOMDP", lib="~/R/win-library/3.6")
install()
usethis::use_coverage(type = "coveralls")
library(smsPOMDP)
run_application()
library(smsPOMDP)
run_application()
usethis::use_travis()
usethis::use_coverage()
usethis::use_coverage()
usethis::use_travis()
usethis::use_coverage()
git pull
usethis::use_test(sim)
library(smsPOMDP)
library(devtools)
build()
install()
usethis::use_test(sim)
usethis::use_test()
usethis::use_test('sim.R')
?graph
?sim
library(vdiffr)
manage_cases()
manage_cases()
remove.packages("smsPOMDP", lib="~/R/win-library/3.6")
build()
install()
test_check("smsPOMDP")
test_check("smsPOMDP")
library(vdiffr)
manage_cases()
manage_cases()
library(shinytest)
appdir <- system.file(package = "smsPOMDP", "app")
appdir
shinytest::recordTest(appdir)
shinytest::recordTest(appdir)
shinytest::recordTest(appdir)
shinytest::recordTest(appdir)
shinytest::recordTest(appdir)
shinytest::recordTest(appdir)
shinytest::recordTest(appdir)
library(shinytest)
?
testApp
?shinyAppDir
?test_that
run_applicationa <- function(){
app <- shiny::shinyApp(
ui <- shiny::fluidPage(
shiny::titlePanel("POMDP solver: When to stop managing or surveying cryptic threatened species ?"),
shiny::sidebarLayout(
shiny::sidebarPanel("POMDP parameters"
, shiny::numericInput('p0', 'Local probability of persistence (if survey or stop)', min = 0, max = 1, value = 0.9)
, shiny::numericInput('pm', 'Local probability of persistence (if manage)', min = 0, max = 1, value = 0.94184)
, shiny::numericInput('d0', 'Local probability of detection (if manage or stop)', min = 0, max = 1, value = 0.01)
, shiny::numericInput('d', 'Local probability of detection (if survey)', min = 0, max = 1, value = 0.78193)
, shiny::numericInput('V', 'Estimated economic value of the species ($/yr)', value = 175.133)
, shiny::numericInput('Cm', 'Estimated cost of managing ($/yr)', value = 18.784)
, shiny::numericInput('Cs', 'Estimated cost of surveying ($/yr)', min = 0, max = 1, value = 10.840)
, shiny::numericInput('disc', 'Discount factor', value = 0.95, max = 1, min = 0)
, shiny::actionButton('sim', 'View simulation')
, shiny::actionButton('graph', 'View graphical solution')
, shiny::actionButton('past', 'Set history of management and observations')
, shiny::conditionalPanel('input.sim'
, shiny::helpText('Parameters only for the simulation')
, shiny::numericInput('Tmax', 'Duration of simulation', value = 10, min = 1)
, shiny::numericInput('b', 'Initial belief state (extant)', value = 1, min = 0, max = 1)
)
)
, shiny::mainPanel(""
, shiny::uiOutput('main')
)
)
),
server <- function(input, output, session){
#Inputs
p0 <- shiny::reactive({
shiny::validate( shiny::need(input$p0 >=0 & input$p0 <=1 , "Please select local probability of persistence (if survey or stop) between 0 and 1") )
input$p0
})
pm <- shiny::reactive({
shiny::validate( shiny::need(input$pm >=0 & input$pm<=1 , "Please select local probability of persistence (if manage) between 0 and 1") )
input$pm
})
d0 <- shiny::reactive({
shiny::validate( shiny::need(input$d0 >=0 & input$d0 <=1 , "Please select local probability of detection (if manage or stop) between 0 and 1") )
input$d0
})
d <- shiny::reactive({
shiny::validate( shiny::need(input$d >=0 & input$d <=1 , "Please select local probability of detection (if survey) between 0 and 1") )
input$d
})
V <- shiny::reactive({
shiny::validate( shiny::need(input$V >=0 , "Please select estimated economic value of the species ($/yr) positive") )
input$V
})
Cm <- shiny::reactive({
shiny::validate( shiny::need(input$Cm >=0, "Please select estimated cost of managing ($/yr) positive") )
input$Cm
})
Cs <- shiny::reactive({
shiny::validate( shiny::need(input$Cs >=0, "Please select estimated cost of survey ($/yr) positive") )
input$Cs
})
disc <- shiny::reactive({
shiny::validate( shiny::need(input$disc >=0 & input$disc <=1 , "Please select a discount factor between 0 and 1") )
input$disc
})
b <- shiny::reactive({
shiny::validate( shiny::need(input$b >=0 & input$b <=1 , "Please select initial belief state (extant) between 0 and 1") )
input$b
})
state_prior <- shiny::reactive({c(b(), 1-b())})
Tmax <- shiny::reactive({
shiny::validate( shiny::need(input$Tmax >=0, "Please select a positive duration of simulation") )
input$Tmax
})
#different scenarios depending on the users choice
#launch a simulation
shiny::observeEvent(input$sim, {
output$plot <- shiny::renderPlot({smsPOMDP::sim(p0(), pm(), d0(), d(), V(), Cm(), Cs(), state_prior(), Tmax(), disc(), size = 2)})
output$main <- shiny::renderUI({
shiny::plotOutput('plot', height = '1000px')
})
})
#see decision graph
shiny::observeEvent(input$graph, {
output$plot <- shiny::renderPlot({smsPOMDP::graph(p0(), pm(), d0(), d(), V(), Cm(), Cs(), c(1,0), disc(), size = 2)})
output$main <- shiny::renderUI({
shiny::plotOutput('plot', height = '1000px')
})
})
#################################################################################
#give a set of past actions and observations and see the best following strategy#
#################################################################################
#correponding panel
shiny::observeEvent(input$past, {
output$main <- shiny::renderUI({
shiny::tagList(
shiny::column(width = 2
, shiny::numericInput('length_past', "Number of years for past management", value = 1, min = 1)
, shiny::actionButton('submit_length_past', 'Submit')
, shiny::uiOutput('past_control')
)
, shiny::column(width = 9
, shiny::plotOutput('past_plot')
, shiny::conditionalPanel('input.submit_couple_1'
, shiny::actionButton('next_policy', 'Next policy')
, shiny::plotOutput('next_policy_plot')
)
)
)
})
})
#set past management stream
shiny::observeEvent(input$submit_length_past,{
output$past_control <- shiny::renderUI({
shiny::tagList(
shiny::numericInput(inputId = 'past_init_b', 'Initial belief state (extant)', value = 1, min = 0, max = 1)
, shiny::h5(paste0('Year ', 1))
, shiny::selectInput(inputId = paste0("past_action_", 1)
,label = 'Action'
,choices = c('Manage', 'Survey', 'Stop')
, selected = 'Manage')
, shiny::selectInput(inputId = paste0("past_obs_", 1)
,label = 'Observation'
,choices = c('Seen', 'Not_seen')
, selected = 'Seen')
, shiny::actionButton(inputId = paste0("submit_couple_", 1)
, label = 'Submit')
, shiny::conditionalPanel('input.length_past > 1',
lapply(c(2:input$length_past),
function(i){
shiny::conditionalPanel(paste0('input.submit_couple_', i-1)
, shiny::h5(paste0('Year ', i))
, shiny::selectInput(inputId = paste0("past_action_", i)
,label = 'Action'
,choices = c('Manage', 'Survey', 'Stop')
, selected = 'Manage')
, shiny::selectInput(inputId = paste0("past_obs_", i)
,label = 'Observation'
,choices = c('Seen', 'Not_seen')
, selected = 'Seen')
, shiny::actionButton(inputId = paste0("submit_couple_", i)
, label = 'Submit')
)
})
)
)
})
})
p_a <- shiny::reactive(smsPOMDP::past_actions(input)) #past actions
p_o <- shiny::reactive(smsPOMDP::past_obs(input)) #past observations
init_belief <- shiny::reactive({
shiny::validate( shiny::need(input$past_init_b >=0 & input$past_init_b <=1 , "Please select initial belief state (extant) between 0 and 1") )
c(input$past_init_b, 1-input$past_init_b)
}) #initial belief state
current_belief <- shiny::reactive(smsPOMDP::compute_belief(p0(), pm(), d0(), d(), V(), Cm(), Cs(),init_belief(), p_a(), p_o(), disc()))
#
shiny::observeEvent(input$submit_couple_1, {
output$past_plot <- shiny::renderPlot(smsPOMDP::plot_stream(p0(), pm(), d0(), d(), V(), Cm(), Cs(),init_belief(), p_a(), p_o(), disc(), size = 2))
})
shiny::observeEvent(input$next_policy, {
output$next_policy_plot <- shiny::renderPlot({smsPOMDP::graph(p0(), pm(), d0(), d(), V(), Cm(), Cs(), current_belief(), disc())})
})
}
)
return(shiny::shinyApp(ui, server))
}
run_applicationa()
class(run_applicationa())
class(run_application=())
class(run_application())
library(smsPOMDP)
class(run_application())
isRunning()
run_application()
run_application()
isRunning()
isRunning(run_application())
expect_output(run_application(), "shiny.appobj")
testthat::expect_output(run_application(), "shiny.appobj")
testthat::expect_output(run_applicationa(), "shiny.appobj")
testthat::expect_output(class(run_applicationa()), "shiny.appobj")
class(run_applicationa())
testthat::expect_equal(class(run_applicationa()), "shiny.appobj")
testthat::expect_equal(class(run_application()), "shiny.appobj")
build()
library(devtools)
build()
install()
t1 <- array(0.5, dim = c(1,2,3))
t1
c()
dim(c())
dim(c())[1]
dim(c())[1]<1
dim(c(1,2))
library(smsPOMDP)
?Interp_policy
system.file('app', package = "smsPOMDP")
system.file('testhat/app', package = "smsPOMDP")
library(shiny)
runApp('inst/app/')
library(vdiffr)
manage_cases()
test_file('tests/testthat/test-Interp_policy.R')
pen <- 0.1 #local probability of extinction P(extinct/extant, survey or nothing)
p0 <- 1-pen #local probability of persitance P(extant/extant, manage)
pem <- 0.05816 #local probability of extinction if managed P(extinct/extant, manage)
pm <- 1 - pem #local probability of persistance if managed P(extant/extant, manage)
d0 <- 0.01 #local probability of detection P(present/extant, manage or nothing)
d <- 0.78193 #local probability of detection if surveyed P(present/extant, survey)
V <- 175.133 #Estimated economic value of the species ($/yr)
Cm <- 18.784 #Estimated cost of managing ($/yr)
Cs <- 10.840 #Estimated cost of surveying ($/yr)
disc <- 0.95
#buiding the matrices of the problem
t <- smsPOMDP::tr(p0, pm, d0, d, V, Cm, Cs) #transition matrix
o <- smsPOMDP::obs(p0, pm, d0, d, V, Cm, Cs)#observation matrix
r <- smsPOMDP::rew(p0, pm, d0, d, V, Cm, Cs) #reward matrix
state_prior <- c(0.5,0.5) #initial belief state
log_dir <- tempdir()
id <- 'test-Interp_policy'
infile <- paste0(log_dir, "/", id, ".pomdpx")
outfile <- paste0(log_dir, "/", id, ".policyx")
stdout <- paste0(log_dir, "/", id, ".log")
sarsop::write_pomdpx(t, o, r, disc, state_prior, file = infile)
status <- sarsop::pomdpsol(infile, outfile, stdout = stdout)
policy <- sarsop::read_policyx(file = outfile)
output <- smsPOMDP::Interp_policy(state_prior,policy$vectors,policy$action)
output = c(output)
expect_equal(length(output), 2)#value and actions
#2nd case
state_prior <- c(0,0) #initial belief state
log_dir <- tempdir()
id <- 'test-Interp_policy'
infile <- paste0(log_dir, "/", id, ".pomdpx")
outfile <- paste0(log_dir, "/", id, ".policyx")
stdout <- paste0(log_dir, "/", id, ".log")
sarsop::write_pomdpx(t, o, r, disc, state_prior, file = infile)
status <- sarsop::pomdpsol(infile, outfile, stdout = stdout)
policy <- sarsop::read_policyx(file = outfile)
output <- smsPOMDP::Interp_policy(state_prior,policy$vectors,policy$action)
output = c(output)
id <- 'test-Interp_policy2'
infile <- paste0(log_dir, "/", id, ".pomdpx")
outfile <- paste0(log_dir, "/", id, ".policyx")
stdout <- paste0(log_dir, "/", id, ".log")
sarsop::write_pomdpx(t, o, r, disc, state_prior, file = infile)
status <- sarsop::pomdpsol(infile, outfile, stdout = stdout)
log_dir
log_dir <- tempdir()
log_dir
id <- 'test-Interp_policy2'
infile <- paste0(log_dir, "/", id, ".pomdpx")
outfile <- paste0(log_dir, "/", id, ".policyx")
stdout <- paste0(log_dir, "/", id, ".log")
sarsop::write_pomdpx(t, o, r, disc, state_prior, file = infile)
status <- sarsop::pomdpsol(infile, outfile, stdout = stdout)
#2nd case
state_prior <- c(0,0) #initial belief state
output <- smsPOMDP::Interp_policy(state_prior,policy$vectors,policy$action)
output = c(output)
expect_equal(length(output), 2)#value and actions
output
#buiding the matrices of the problem
t <- smsPOMDP::tr(p0, pm, d0, d, V, Cm, Cs) #transition matrix
o <- smsPOMDP::obs(p0, pm, d0, d, V, Cm, Cs)#observation matrix
r <- smsPOMDP::rew(p0, pm, d0, d, V, Cm, Cs) #reward matrix
state_prior <- c(0.5,0.5) #initial belief state
log_dir <- tempdir()
id <- 'test-Interp_policy'
infile <- paste0(log_dir, "/", id, ".pomdpx")
outfile <- paste0(log_dir, "/", id, ".policyx")
stdout <- paste0(log_dir, "/", id, ".log")
sarsop::write_pomdpx(t, o, r, disc, state_prior, file = infile)
status <- sarsop::pomdpsol(infile, outfile, stdout = stdout)
policy <- sarsop::read_policyx(file = outfile)
output <- smsPOMDP::Interp_policy(state_prior,policy$vectors,policy$action)
output = c(output)
expect_equal(length(output), 2)#value and actions
#2nd case
state_prior <- c(0,0) #initial belief state
output <- smsPOMDP::Interp_policy(state_prior,policy$vectors,policy$action)
output = c(output)
expect_equal(length(output), 2)#value and actions
expect_equal(output[1], 0)#value
output
expect_equal(output[[1]], 0)#value
expect_equal(output[[2]], 1)#action
m2 <- matrix(c(-1,2,2,-1), ncol = 2)
testthat::expect_false(smsPOMDP::check_stochastic(m2))
smsPOMDP::check_stochastic(m2)
