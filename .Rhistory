expect_length(current,2)#belief state: 2 states, length of current is 2
expect_equal(current[1]+current[2],1)#current should be a probability distribution
expect_gt(current[1],0)
expect_gt(current[2],0)
expect_lt(current[1],1)
expect_lt(current[2],2)
#is current a distribution over 2 states
expect_length(current,2)#belief state: 2 states, length of current is 2
expect_equal(current[1]+current[2],1)#current should be a probability distribution
expect_gte(current[1],0)
expect_gte(current[2],0)
expect_lte(current[1],1)
expect_lte(current[2],2)
pen = 0.1 #local probability of extinction P(extinct/extant, survey or nothing)
p0 = 1-pen #local probability of persitance P(extant/extant, manage)
pem = 0.05816 #local probability of extinction if managed P(extinct/extant, manage)
pm = 1 - pem #local probability of persistance if managed P(extant/extant, manage)
d0 = 0.01 #local probability of detection P(present/extant, manage or nothing)
d = 0.78193 #local probability of detection if surveyed P(present/extant, survey)
V = 175.133 #Estimated economic value of the species ($/yr)
Cm = 18.784 #Estimated cost of managing ($/yr)
Cs = 10.840 #Estimated cost of surveying ($/yr)
#Initial belief state
state_prior = c(0.9,0.1) #extant : 0.9, extinct : 0.1
#test1: last observation is seen: current belief state is [1,0], the species is extant
#previous actions and observations
ac = c('Manage','Survey','Stop')
ob = c('Seen','Not_seen','Not_seen')
current = compute_belief(p0, pm, d0, d, V, Cm, Cs, state_prior, ac, ob)#current belief state
#is current a distribution over 2 states
expect_length(current,2)#belief state: 2 states, length of current is 2
expect_gte(current[1],0)
expect_gte(current[2],0)
expect_lte(current[1],1)
expect_lte(current[2],2)
expect_equal(current[1]+current[2],1)#current should be a probability distribution
expect_lt(current[1],1)# last observation is seen: current belief state is [1,0], the species is extant
?compute_belief
?tab_actions
install.packages("MDPtoolbox")
library(MDPtoolbox)
?`MDPtoolbox-package`
trace(mdp_check_square_stochastic, edit =T)
check_square_stochastic = function(X){
error_msg = T
s1 <- dim(X)[1]
s2 <- dim(X)[2]
if (s1 != s2) {
error_msg <-F
}
else if (max(abs(rowSums(X) - rep(1, s2))) > 10^(-12)) {
error_msg <-F
}
else if (length(which(X < 0)) > 0) {
error_msg <-F
}
return(error_msg)
}
stopifnot(check_square_stochastic(t[,,1]))
check_square_stochastic(t[,,1])
stopifnot(check_square_stochastic(t[,,1]))
stopifnot(check_square_stochastic(t[,,2]))
stopifnot(check_square_stochastic(t[,,3]))
?mdp_check
trace(mdp_check, edit =T)
trace(sarsop, edit =T)
trace(write_pomdpx, edit =T)
#' @export
tab_actions = function(transition, observation, reward, state_prior, disc = 0.95){
stopifnot(check_square_stochastic(t[,,1]))
stopifnot(check_square_stochastic(t[,,2]))
stopifnot(check_square_stochastic(t[,,3]))
log_dir = tempdir()
id <- digest::digest(match.call())
infile <- paste0(log_dir, "/", id, ".pomdpx")
outfile <- paste0(log_dir, "/", id, ".policyx")
stdout <- paste0(log_dir, "/", id, ".log")
sarsop::write_pomdpx(transition, observation, reward, disc, state_prior, file = infile)
status <- sarsop::pomdpsol(infile, outfile, stdout = stdout)
policy <- sarsop::read_policyx(file = outfile)
output <- smsPOMDP::Interp_policy(state_prior,policy$vectors,policy$action)
state_posterior = matrix(state_prior, ncol = 2)
optimal_action = output[[2]]
Tmax = 100
for (i in c(1:(Tmax))) {
a1 = optimal_action[i]
o1 = 2 #we treat the case when the species is not seen
s_p <- smsPOMDP::update_belief(state_posterior[i, ], transition, observation, o1,
a1)
state_posterior = rbind(state_posterior, s_p)
output <- Interp_policy(s_p,policy$vectors,policy$action)
optimal_action = c(optimal_action, output[[2]])
}
a = optimal_action[1]
act = a
years = numeric()
while(sum(years) < length(optimal_action)){
if (length(unique(optimal_action))==1){
i = length(optimal_action)
years = c(years, i)
break
} else {
i = min(which(optimal_action!= a))-1
optimal_action = optimal_action[-c(1:i)]
a = optimal_action[1]
act = c(act,a)
years = c(years, i)
}
}
tab = data.frame(action = act, years = years)
return(tab)
}
t
is_error_detected <- FALSE
error_msg <- ""
if (is.list(t)) {
s1 <- dim(t[[1]])[1]
s2 <- dim(t[[1]])[2]
a1 <- length(t)
}
else {
s1 <- dim(t)[1]
s2 <- dim(t)[2]
a1 <- dim(t)[3]
}
is_error_detected <- FALSE
error_msg <- ""
if (is.list(t)) {
s1 <- dim(t[[1]])[1]
s2 <- dim(t[[1]])[2]
a1 <- length(t)
} else {
s1 <- dim(t)[1]
s2 <- dim(t)[2]
a1 <- dim(t)[3]
}
s1
s2
a1
if (s1 < 1 | a1 < 1 | s1 != s2) {
error_msg <- "MDP Toolbox ERROR: The transition matrix must be on the form P(S,S,A) with S : number of states greater than 0 and A : number of action greater than 0"
is_error_detected <- T
}
inherits
o
dim(o)
library(smsPOMDP)
?update_belief
context("smsPOMDP")
?test_that
??test_that
?testthat
??testthat
library(testthat)
?expect_plot
??expect_plot
setwd('~/smsPOMDP/tests/')
devtools::test()
?expect_length
install.packages("vdiffr")
library(vdiffr)
?expect_doppelganger
manage_cases()
run_application()
?plot_stream
context("Histograms")
disp_hist_base <- function() hist(mtcars$disp)
disp_hist_ggplot <- ggplot(mtcars, aes(disp)) + geom_histogram()
library(ggplot)
library(gplot)
library(ggplot2)
install.packages("ggplot2")
library(ggplot2)
disp_hist_base <- function() hist(mtcars$disp)
disp_hist_ggplot <- ggplot(mtcars, aes(disp)) + geom_histogram()
vdiffr::expect_doppelganger("Base graphics histogram", disp_hist_base)
test_that('asdf',
disp_hist_base <- function() hist(mtcars$disp)
disp_hist_ggplot <- ggplot(mtcars, aes(disp)) + geom_histogram()
vdiffr::expect_doppelganger("Base graphics histogram", disp_hist_base)
vdiffr::expect_doppelganger("ggplot2 histogram", disp_hist_ggplot)
)
test_that('asdf',
disp_hist_base <- function() hist(mtcars$disp)
disp_hist_ggplot <- ggplot(mtcars, aes(disp)) + geom_histogram()
vdiffr::expect_doppelganger("Base graphics histogram", disp_hist_base)
vdiffr::expect_doppelganger("ggplot2 histogram", disp_hist_ggplot)
)
test_that('asdf',
disp_hist_base <- function() hist(mtcars$disp)
disp_hist_ggplot <- ggplot(mtcars, aes(disp)) + geom_histogram()
vdiffr::expect_doppelganger("Base graphics histogram", disp_hist_base)
vdiffr::expect_doppelganger("ggplot2 histogram", disp_hist_ggplot)
)
getwd()
setwd('~')
install('smsPOMDP/')
install('smsPOMDP')
library(devtools)
install('smsPOMDP')
install.packages(c("devtools", "hms", "pkgbuild", "sys", "whisker", "xfun"))
install('smsPOMDP')
library(devtools)
install('smsPOMDP')
test('smsPOMDP')
?expect_gte
a=9
expect_lt(a, 10)
## Not run:
expect_lt(11, 10)
a <- 11
expect_gt(a, 10)
## Not run:
expect_gt(9, 10)
pen = 0.1 #local probability of extinction P(extinct/extant, survey or nothing)
p0 = 1-pen #local probability of persitance P(extant/extant, manage)
pem = 0.05816 #local probability of extinction if managed P(extinct/extant, manage)
pm = 1 - pem #local probability of persistance if managed P(extant/extant, manage)
d0 = 0.01 #local probability of detection P(present/extant, manage or nothing)
d = 0.78193 #local probability of detection if surveyed P(present/extant, survey)
V = 175.133 #Estimated economic value of the species ($/yr)
Cm = 18.784 #Estimated cost of managing ($/yr)
Cs = 10.840 #Estimated cost of surveying ($/yr)
#Initial belief state
state_prior = c(0.9,0.1) #extant : 0.9, extinct : 0.1
#test1: last observation is not seen: current belief state is not[1,0]
t = smsPOMDP::tr(p0, pm, d0, d, V, Cm, Cs) #transition matrix
o = smsPOMDP::obs(p0, pm, d0, d, V, Cm, Cs)#observation matrix
z0 = 2 #Not seen
a0 = 1 #manage
current = update_belief(state_prior, t, o, z0, a0)
current
expect_gte(10, 10)
library(testthat)
library(smsPOMDP)
test_dir("~/smsPOMDP/tests")
?tab_actions
tab = tab_actions(t, o, r, state_prior)
pen = 0.1
p0 = 1-pen
pem = 0.05816
pm = 1 - pem
V = 175.133
Cm = 18.784
Cs = 10.840
d0 = 0.01
d = 0.78193
t = smsPOMDP::tr(p0, pm, d0, d, V, Cm, Cs) #transition matrix
o = smsPOMDP::obs(p0, pm, d0, d, V, Cm, Cs)#observation matrix
r = smsPOMDP::rew(p0, pm, d0, d, V, Cm, Cs)#reward matrix
state_prior = c(1,0)
tab = tab_actions(t, o, r, state_prior)
t
t
check_square_stochastic(t[,,1])
stopifnot(check_square_stochastic(t[,,1]))
stopifnot(check_square_stochastic(t[,,2]))
stopifnot(check_square_stochastic(t[,,3]))
getwd()
setwd('~')
library(devtools)
install('smsPOMDP')
library(testthat)
library(smsPOMDP)
test_dir("~/smsPOMDP/tests")
pen = 0.1
p0 = 1-pen
pem = 0.05816
pm = 1 - pem
V = 175.133
Cm = 18.784
Cs = 10.840
d0 = 0.01
d = 0.78193
t = smsPOMDP::tr(p0, pm, d0, d, V, Cm, Cs) #transition matrix
o = smsPOMDP::obs(p0, pm, d0, d, V, Cm, Cs)#observation matrix
r = smsPOMDP::rew(p0, pm, d0, d, V, Cm, Cs)#reward matrix
state_prior = c(1,0)
tab = smsPOMDP::tab_actions(t, o, r, state_prior)
tab
?expect_equal
dim(tab)
length(tab)
expect_equal(dim(tab)[2],2)
Tmax = 100
expect_equal(sum(tab[,2]), Tmax)#2 rows
expect_equal(sum(tab[,2]), Tmax+1)#2 rows
library(smsPOMDP)
run_application()
1069-779,84-170
1069-779,84-170
1069-779,84-170
1069-779.84-170
tab
library(smsPOMDP)
run_application()
run_application()
unique(actions)
actions = tab$action
unique(actions)
library(testthat)
?expect_equal
actions %in% c(1,2,3)
expect_true(actions %in% c(1,2,3))
expect_true(unique(actions %in% c(1,2,3)))
pen = 0.1
p0 = 1-pen
pem = 0.05816
pm = 1 - pem
V = 175.133
Cm = 18.784
Cs = 10.840
d0 = 0.01
d = 0.78193
t = smsPOMDP::tr(p0, pm, d0, d, V, Cm, Cs) #transition matrix
o = smsPOMDP::obs(p0, pm, d0, d, V, Cm, Cs)#observation matrix
r = smsPOMDP::rew(p0, pm, d0, d, V, Cm, Cs)#reward matrix
Tmax = 100
#different values for the state prior
state_prior = c(1,0)
tab = smsPOMDP::tab_actions(t, o, r, state_prior)
expect_equal(dim(tab)[2],2)#2 rows
expect_equal(sum(tab[,2]), Tmax+1)#Tmax + 1 years planning
actions = tab$action
expect_true(unique(actions %in% c(1,2,3))) #the list of actions is in c(1,2,3)
state_prior = c(0.9,0.1)
tab = smsPOMDP::tab_actions(t, o, r, state_prior)
expect_equal(dim(tab)[2],2)#2 rows
expect_equal(sum(tab[,2]), Tmax+1)#Tmax + 1 years planning
actions = tab$action
expect_true(unique(actions %in% c(1,2,3))) #the list of actions is in c(1,2,3)
state_prior = c(0.8,0.2)
tab = smsPOMDP::tab_actions(t, o, r, state_prior)
expect_equal(dim(tab)[2],2)#2 rows
expect_equal(sum(tab[,2]), Tmax+1)#Tmax + 1 years planning
actions = tab$action
expect_true(unique(actions %in% c(1,2,3))) #the list of actions is in c(1,2,3)
state_prior = c(0.7,0.3)
tab = smsPOMDP::tab_actions(t, o, r, state_prior)
expect_equal(dim(tab)[2],2)#2 rows
expect_equal(sum(tab[,2]), Tmax+1)#Tmax + 1 years planning
actions = tab$action
expect_true(unique(actions %in% c(1,2,3))) #the list of actions is in c(1,2,3)
state_prior = c(0.6,0.4)
tab = smsPOMDP::tab_actions(t, o, r, state_prior)
expect_equal(dim(tab)[2],2)#2 rows
expect_equal(sum(tab[,2]), Tmax+1)#Tmax + 1 years planning
actions = tab$action
expect_true(unique(actions %in% c(1,2,3))) #the list of actions is in c(1,2,3)
state_prior = c(0.5,0.5)
tab = smsPOMDP::tab_actions(t, o, r, state_prior)
expect_equal(dim(tab)[2],2)#2 rows
expect_equal(sum(tab[,2]), Tmax+1)#Tmax + 1 years planning
actions = tab$action
expect_true(unique(actions %in% c(1,2,3))) #the list of actions is in c(1,2,3)
state_prior = c(0.4,0.6)
tab = smsPOMDP::tab_actions(t, o, r, state_prior)
expect_equal(dim(tab)[2],2)#2 rows
expect_equal(sum(tab[,2]), Tmax+1)#Tmax + 1 years planning
actions = tab$action
expect_true(unique(actions %in% c(1,2,3))) #the list of actions is in c(1,2,3)
state_prior = c(0.3,0.7)
tab = smsPOMDP::tab_actions(t, o, r, state_prior)
expect_equal(dim(tab)[2],2)#2 rows
expect_equal(sum(tab[,2]), Tmax+1)#Tmax + 1 years planning
actions = tab$action
expect_true(unique(actions %in% c(1,2,3))) #the list of actions is in c(1,2,3)
state_prior = c(0.2,0.8)
tab = smsPOMDP::tab_actions(t, o, r, state_prior)
expect_equal(dim(tab)[2],2)#2 rows
expect_equal(sum(tab[,2]), Tmax+1)#Tmax + 1 years planning
actions = tab$action
expect_true(unique(actions %in% c(1,2,3))) #the list of actions is in c(1,2,3)
state_prior = c(0.1,0.9)
tab = smsPOMDP::tab_actions(t, o, r, state_prior)
expect_equal(dim(tab)[2],2)#2 rows
expect_equal(sum(tab[,2]), Tmax+1)#Tmax + 1 years planning
actions = tab$action
expect_true(unique(actions %in% c(1,2,3))) #the list of actions is in c(1,2,3)
state_prior = c(0,1)
tab = smsPOMDP::tab_actions(t, o, r, state_prior)
expect_equal(dim(tab)[2],2)#2 rows
expect_equal(sum(tab[,2]), Tmax+1)#Tmax + 1 years planning
actions = tab$action
expect_true(unique(actions %in% c(1,2,3))) #the list of actions is in c(1,2,3)
?past_actions
?sim
#values for Sumatran tigers
pen = 0.1
p0 = 1-pen
pem = 0.05816
pm = 1 - pem
V = 175.133
Cm = 18.784
Cs = 10.840
d0 = 0.01
d = 0.78193
#Initial belief state
state_prior = c(0.9,0.1) #extant : 0.9, extinct : 0.1
#Horizon of the simulation
Tmax = 20
sim(p0, pm, d0, d, V, Cm, Cs, state_prior, Tmax)
library(testthat)
library(smsPOMDP)
test_dir("~/smsPOMDP/tests")
library(smsPOMDP)
?plot_stream
#values for Sumatran tigers
pen = 0.1
p0 = 1-pen
pem = 0.05816
pm = 1 - pem
V = 175.133
Cm = 18.784
Cs = 10.840
d0 = 0.01
d = 0.78193
s = c(1,0)
act = c('Manage', 'Manage', 'Survey','Stop')
obs = c('Not_seen','Not_seen','Not_seen','Seen')
plot_stream(p0, pm, d0, d, V, Cm, Cs, s, act, obs, disc = 0.95, size = 1)
plot_stream(p0, pm, d0, d, V, Cm, Cs, s, act, obs, disc = 0.95, size = 1)
library(vdiffr)
?expect_doppelganger()
library("ggplot2")
test_that("plots have known output", {
disp_hist_base <- function() hist(mtcars$disp)
expect_doppelganger("disp-histogram-base", disp_hist_base)
disp_hist_ggplot <- ggplot(mtcars, aes(disp)) + geom_histogram()
expect_doppelganger("disp-histogram-ggplot", disp_hist_ggplot)
})
library(devtools)
library("ggplot2")
test_that("plots have known output", {
disp_hist_base <- function() hist(mtcars$disp)
expect_doppelganger("disp-histogram-base", disp_hist_base)
disp_hist_ggplot <- ggplot(mtcars, aes(disp)) + geom_histogram()
expect_doppelganger("disp-histogram-ggplot", disp_hist_ggplot)
})
disp_hist_base <- function() hist(mtcars$disp)
expect_doppelganger("disp-histogram-base", disp_hist_base)
?manage_cases
manage_cases()
manage_cases("smsPOMDP")
setwd(~)
setwd('~')
manage_cases("smsPOMDP")
install('smsPOMDP')
install.packages("httpuv")
install('smsPOMDP')
library(devtools)
install('smsPOMDP')
library(testthat)
library(vdiffr)
manage_cases()
getwd()
manage_cases('smsPOMDP')
?expect_length
pen = 0.1 #local probability of extinction P(extinct/extant, survey or nothing)
p0 = 1-pen #local probability of persitance P(extant/extant, manage)
pem = 0.05816 #local probability of extinction if managed P(extinct/extant, manage)
pm = 1 - pem #local probability of persistance if managed P(extant/extant, manage)
d0 = 0.01 #local probability of detection P(present/extant, manage or nothing)
d = 0.78193 #local probability of detection if surveyed P(present/extant, survey)
V = 175.133 #Estimated economic value of the species ($/yr)
Cm = 18.784 #Estimated cost of managing ($/yr)
Cs = 10.840 #Estimated cost of surveying ($/yr)
#buiding the matrices of the problem
t = smsPOMDP::tr(p0, pm, d0, d, V, Cm, Cs) #transition matrix
o = smsPOMDP::obs(p0, pm, d0, d, V, Cm, Cs)#observation matrix
r = smsPOMDP::rew(p0, pm, d0, d, V, Cm, Cs) #reward matrix
state_prior = c(0.5,0.5) #initial belief state
log_dir = tempdir()
id <- digest::digest(match.call())
infile <- paste0(log_dir, "/", id, ".pomdpx")
outfile <- paste0(log_dir, "/", id, ".policyx")
stdout <- paste0(log_dir, "/", id, ".log")
sarsop::write_pomdpx(t, o, r, disc, state_prior, file = infile)
status <- sarsop::pomdpsol(infile, outfile, stdout = stdout)
policy <- sarsop::read_policyx(file = outfile)
output <- smsPOMDP::Interp_policy(state_prior,policy$vectors,policy$action)
disc = 0.95
#buiding the matrices of the problem
t = smsPOMDP::tr(p0, pm, d0, d, V, Cm, Cs) #transition matrix
o = smsPOMDP::obs(p0, pm, d0, d, V, Cm, Cs)#observation matrix
r = smsPOMDP::rew(p0, pm, d0, d, V, Cm, Cs) #reward matrix
state_prior = c(0.5,0.5) #initial belief state
log_dir = tempdir()
id <- digest::digest(match.call())
infile <- paste0(log_dir, "/", id, ".pomdpx")
outfile <- paste0(log_dir, "/", id, ".policyx")
stdout <- paste0(log_dir, "/", id, ".log")
sarsop::write_pomdpx(t, o, r, disc, state_prior, file = infile)
status <- sarsop::pomdpsol(infile, outfile, stdout = stdout)
policy <- sarsop::read_policyx(file = outfile)
output <- smsPOMDP::Interp_policy(state_prior,policy$vectors,policy$action)
output
dim(output)
size(output)
length()
length(output)
getwd()
install('smsPOMDP')
manage_cases('smsPOMDP')
vdiffr::last_collection_error()
library(smsPOMDP)
run_application()
library(vdiffr)
?vdiffr
collect_cases()
last_collection_error()
?last_collection_error
